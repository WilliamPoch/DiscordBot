"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = require("path");
const util_1 = require("../utils/util");
const fs_1 = require("../fs");
const remove_1 = require("./remove");
const mkdirs_1 = require("./mkdirs");
const pathExists_1 = require("./pathExists");
const copy_1 = require("./copy");
/**
 * @function move
 * @memberof fsn/nextra
 * @param source The source path of the file
 * @param destination The destination path of the file
 * @param options The options for the move
 */
async function move(source, destination, options = {}) {
    const overwrite = options.overwrite || false;
    if (path_1.resolve(source) === path_1.resolve(destination))
        return fs_1.access(source);
    const myStat = await fs_1.stat(source);
    if (myStat.isDirectory() && util_1.isSrcKid(source, destination)) {
        throw new Error('FS-NEXTRA: Moving a parent directory into a child will result in an infinite loop.');
    }
    await mkdirs_1.default(path_1.dirname(destination));
    if (overwrite) {
        await remove_1.default(destination);
    }
    else if (await pathExists_1.default(destination)) {
        throw new Error('FS-NEXTRA: Destination already exists.');
    }
    try {
        return await fs_1.rename(source, destination);
    }
    catch (err) {
        // Cross network moving: Can't test via travis
        /* istanbul ignore next */
        if (err.code === 'EXDEV') {
            const opts = {
                overwrite,
                errorOnExist: true
            };
            await copy_1.default(source, destination, opts);
            return remove_1.default(source);
        }
        // Hard to produce, such as ENOMEM (Kernel running out of memory): Can't test via travis
        /* istanbul ignore next */
        throw err;
    }
}
exports.default = move;
//# sourceMappingURL=move.js.map