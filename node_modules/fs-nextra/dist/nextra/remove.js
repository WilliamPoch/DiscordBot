"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = require("path");
const util_1 = require("../utils/util");
const fs_1 = require("../fs");
/**
 * Removes a single file or single directory with no children.
 * @function remove
 * @memberof fsn/nextra
 * @param path The path to remove
 * @param options The remove options
 */
async function remove(path, options = {}) {
    options.maxBusyTries = typeof options.maxBusyTries === 'undefined' ? 3 : options.maxBusyTries;
    for (let buysTries = 0; buysTries < options.maxBusyTries; buysTries++) {
        try {
            await rimraf(path, options);
            break;
        }
        catch (err) {
            // Windows
            /* istanbul ignore next */
            if (util_1.isWindows && (err.code === 'EBUSY' || err.code === 'ENOTEMPTY' || err.code === 'EPERM')) {
                await util_1.setTimeoutPromise(buysTries * 100);
                continue;
            }
            // Hard to test via travis, such as ENOMEM (running the kernel out of memory)
            /* istanbul ignore else */
            if (err.code === 'ENOENT')
                return;
            else
                throw err;
        }
    }
}
exports.default = remove;
const rimraf = async (myPath, options) => {
    try {
        const stats = await fs_1.lstat(myPath);
        if (stats.isDirectory())
            return removeDir(myPath, options);
    }
    catch (err) {
        // Windows
        /* istanbul ignore next */
        if (util_1.isWindows && err.code === 'EPERM')
            return fixWinEPERM(myPath, options);
        throw err;
    }
    try {
        return await fs_1.unlink(myPath);
    }
    catch (er) {
        // Windows
        /* istanbul ignore next */
        if (er.code === 'EPERM')
            return util_1.isWindows ? fixWinEPERM(myPath, options) : removeDir(myPath, options, er);
        // Difficult to reproduce
        /* istanbul ignore next */
        if (er.code === 'EISDIR')
            return removeDir(myPath, options, er);
        else
            throw er;
    }
};
// Windows
/* istanbul ignore next */
const fixWinEPERM = async (myPath, options) => {
    await fs_1.chmod(myPath, 0o666);
    return rimraf(myPath, options);
};
const removeDir = async (myPath, options, originalEr = null) => {
    try {
        return await fs_1.rmdir(myPath);
    }
    catch (err) {
        // Difficult to reproduce
        /* istanbul ignore else */
        if (['ENOTEMPTY', 'EEXIST', 'EPERM'].includes(err.code))
            return rmkids(myPath, options);
        else if (err.code === 'ENOTDIR')
            throw originalEr;
        else
            throw err;
    }
};
const rmkids = async (myPath, options) => {
    const files = await fs_1.readdir(myPath);
    await Promise.all(files.map(file => remove(path_1.join(myPath, file), options)));
    return fs_1.rmdir(myPath);
};
//# sourceMappingURL=remove.js.map