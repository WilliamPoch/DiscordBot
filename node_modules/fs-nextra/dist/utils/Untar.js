"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const stream_1 = require("stream");
const header_1 = require("./header");
class Untar extends stream_1.Writable {
    constructor() {
        super(...arguments);
        this.header = null;
        this.file = Buffer.alloc(0);
        this.totalRead = 0;
        this.recordSize = 512;
        this.queue = [];
    }
    _write(data, encoding, next) {
        this.file = Buffer.concat([this.file, data], this.file.length + data.length);
        if (this.file.length === 0)
            return next();
        // file
        if (this.header) {
            if (this.file.length >= this.header.size) {
                this.send();
                return this._write(Buffer.alloc(0), encoding, next);
            }
            return next();
        }
        // Remove extra bits between files
        if (this.totalRead % this.recordSize) {
            this.slice(Math.min(this.recordSize - (this.totalRead % this.recordSize), this.file.length));
            return this._write(Buffer.alloc(0), encoding, next);
        }
        // Hard to test, requires the leftover of a chunk to be less than the size of a header block
        /* istanbul ignore next */
        if (this.file.length < this.recordSize)
            return next();
        // New Header
        this.header = header_1.decodeHeader(this.slice(this.recordSize));
        return this._write(Buffer.alloc(0), encoding, next);
    }
    slice(length) {
        const buffer = this.file.slice(0, length);
        this.file = this.file.slice(length);
        this.totalRead += length;
        return buffer;
    }
    send() {
        if (this.listenerCount('file'))
            this.emit('file', this.header, this.slice(this.header.size));
        else
            this.queue.push({ header: this.header, file: this.slice(this.header.size) });
        this.header = null;
    }
    next() {
        if (this.queue.length)
            return Promise.resolve(this.queue.shift());
        if (!this.writable)
            return Promise.resolve(null);
        return new Promise((resolve) => {
            this.once('file', (header, file) => {
                resolve({ header, file });
            });
        });
    }
    async *files() {
        let file;
        while (file = await this.next())
            yield file;
    }
}
exports.default = Untar;
//# sourceMappingURL=Untar.js.map